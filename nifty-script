#!/bin/bash

set -e

NIFTY_GIT_CONFIG_EMAIL=${NIFTY_GIT_CONFIG_EMAIL:=carl.worth+travis@nimbisservices.com}
NIFTY_TRAVIS_JOBS_URL_BASE=https://magnum.travis-ci.com/${TRAVIS_REPO_SLUG}/jobs
NIFTY_TRAVIS_JOB_URL=${NIFTY_TRAVIS_JOBS_URL_BASE}/${TRAVIS_JOB_ID}
NIFTY_TRAVIS_CACHE_DIR=./.travis-cache
# This should be set by the .travis.yml file if the value needs to change,
# like when using a public cache repository.
NIFTY_TRAVIS_CACHE_REPO=${NIFTY_TRAVIS_CACHE_REPO:=git@github.com:nimbis/travis-cache}

# Primary key for travis cache. For this we use the TRAVIS_REPO_SLUG
# and then append the value of $SITE (if set) since we do multiple
# tests for different sites within the same repository.
CACHE_REPO_KEY=${TRAVIS_REPO_SLUG}${SITE:+-}${SITE}

# Absolute path for original clone of repository (so always easy to return to)
SITE_DIR=$(pwd)

reqs_and_decrypt="false"

#####
# At various times, Travis needs to create new git objects, (commits
# within the travis-cache repository, tags after deploying to
# production).
#
# In order to do that, git insists that the user have a valid
# name. So we need to put something in place.
#
# In lieu of any better information, I'll use my email address to take
# responsibility for any actions performed by this script.
#####

__configure_git_authorship() {
    git config user.email "${NIFTY_GIT_CONFIG_EMAIL}"
    git config user.name "${TRAVIS_REPO_SLUG} travis-metadata-script"
}

#####
# Upgrade to latest pip
#
# Travis has pip 6.0.7 installed by default, which does not know how
# to install a local version of a package (such as
# django-shop==0.2.0+nimbis.1).
#####
__ensure_latest_pip() {
    pip install --upgrade pip
}

__ensure_reqs_and_decrypt() {
    if [ "$reqs_and_decrypt" = "false" ]; then

        echo "travis_fold:start:npm"
        sh -e /etc/init.d/xvfb start
        npm install -g grunt-cli
        npm install -g git-encrypt
        npm install -g bower
        echo "travis_fold:end:npm"

        echo "travis_fold:start:decrypt"
        git config filter.encrypt.smudge "gitcrypt smudge"
        git config filter.encrypt.clean "gitcrypt clean"
        git config diff.encrypt.textconv "gitcrypt diff"
        git config gitcrypt.salt ${GITCRYPT_SALT}
        git config gitcrypt.pass ${GITCRYPT_PASS}
        make decrypt

        echo "travis_fold:end:decrypt"

        echo "travis_fold:start:reqs"
        __ensure_latest_pip
        make reqs
        echo "travis_fold:end:reqs"

        reqs_and_decrypt="true"
    fi
}

#####
# Initialize our git-repository-based travis cache.
#
# This function must be called once before any other calls to
# travis_cache functions.
#####

__init_travis_cache() {
    if [ ! -e ${NIFTY_TRAVIS_CACHE_DIR} ]; then
       git clone ${NIFTY_TRAVIS_CACHE_REPO} ${NIFTY_TRAVIS_CACHE_DIR}
    fi

    cd ${NIFTY_TRAVIS_CACHE_DIR}
    # Switch to an absolute path for NIFTY_TRAVIS_CACHE_DIR for better reliability
    NIFTY_TRAVIS_CACHE_DIR=$(pwd)

    git pull --no-edit
    git reset --hard origin/master

    __configure_git_authorship

    cd ${SITE_DIR}
}

#####
# String together all function arguments. For any very long
# arguments, (that is, git commit IDs), split them into two pieces
# after the first two characters.
#####
__args_to_cache_path() {
    path=""

    while [ $# -gt 0 ]; do
    arg=$1
    shift
    if [ ${#arg} -gt 35 ]; then
        arg="${arg:0:2}/${arg:2}"
    fi
    path="${path:+$path/}$arg"
    done

    echo "$path"
}

#####
# Perform a lookup in our git-repository-based travis cache.
#
# This function prints a non-empty string on a cache hit, (which can
# be provided to the user as a URL to see the log from the previous
# Travis run).
#####
__check_travis_cache() {

    cd ${NIFTY_TRAVIS_CACHE_DIR}

    path=$(__args_to_cache_path "$@")

    if [ -e "$path" ]; then
       cat "$path"
    fi

    cd ${SITE_DIR}
}

#####
# Store an item in the travis cache
#
# The first argument should be a URL to store in the cache. All
# remaining arguments are the key, (and should match the arguments
# used later when calling __check_travis_cache).
#####
__store_travis_cache() {

    cd ${NIFTY_TRAVIS_CACHE_DIR}

    url="$1"
    shift

    echo "travis_fold:start:__store_travis_cache_$1"

    path=$(__args_to_cache_path "$@")

    mkdir -p $(dirname "$path")

    echo "$url" > "$path"

    git add "$path"
    git commit -a -m "Add item to travis cache" -m "Path of $path" -m "URL of $url"

    # If the first push fails, pull then push again. If that fails too, give up.
    git push origin master || git pull --no-edit && git push origin master || true

    cd ${SITE_DIR}

    echo "travis_fold:end:__store_travis_cache_$1"
}

#####
# Run tests for the platform subtree.
#####
__travis_for_platform() {
    cd platform

    __ensure_reqs_and_decrypt

    make piprot
    make test
}

#####
# For a push to the sites repository, we push out corresponding
# commits (along with tags) to the site-$SITE repository as well as
# site-common. Those pushes will then result in testing and/or
# deployment from within the site-$SITE repository, so there's nothing
# else we need to do here, (no lettuce tests, no deployment, etc.)
#
# If SITE=platform, which indicates a nimbis-platform build, we simply
# test in house.
#####
travis_for_sites() {

    echo "=================== Running Travis tests for site $SITE ==================="

    # If this is for platform then call the testing function and return.

    if [ "$SITE" = "platform" ]; then
        __travis_for_platform
        return
    fi

    # If this is a commit being pushed to the master branch, then
    # we want to test and deploy to staging.
    #
    # Note: Travis is obnoxious in that it clobbers TRAVIS_BRANCH
    # with the tag name if a tag is being pushed, (even though the
    # same name is set in TRAVIS_TAG too). The upshot is that
    # pushing a tag at the same time as pushing to master will
    # prevent the detection of the master branch here, and will
    # prevent Travis from doing any deployment.
    #
    # If, instead, this is a push of a tag named
    # "production-$SITE" then we want to deploy to production, but
    # *only* for the particular site.
    #
    # Any other case is treated as a feature branch, (it will be
    # tested, but not deployed).

    case "$TRAVIS_BRANCH" in
    master)
        mode="staging"
        ;;
    production-*)
        if [ "$TRAVIS_BRANCH" = "production-$SITE" ]; then
            mode="production"
        else
            echo "This tag $TRAVIS_BRANCH was not intended for site $SITE"
            echo "Exiting"
            return
        fi
        if [ "$SITE" = "tss" ]; then
            echo "Travis is not authorized to deploy to the tss site."
            echo "Exiting"
            return
        fi
        ;;
    *)
        mode="feature"
        ;;
    esac

    #####
    # Nuke all sites other than the one under test
    # (This avoids any accidental inter-site dependencies)
    #####

    for site in awesim nimbisservices smlc tss; do
        if [ "$site" != "$SITE" ]; then
            rm -rf $site
        fi
    done

    #####
    # Check cache and don't repeat tests if succesfully tested before
    #####

    echo "travis_fold:start:__check_travis_cache_tested"
    tested=$(__check_travis_cache tested ${CACHE_REPO_KEY} ${TRAVIS_COMMIT} ${common_commit})
    echo "travis_fold:end:__check_travis_cache_tested"

    if [ -n "$tested" ]; then
        echo "This commit has previously been tested successfully. Not testing again."
        echo ""
        echo "The report from the previous run can be seen here:"
        echo ""
        echo "$tested"
    else

        __ensure_reqs_and_decrypt

        make travis-tests

        #####
        # Now that testing has completed successfully, add a new
        # commit to the cache repository and push it out.
        ####
        __store_travis_cache $NIFTY_TRAVIS_JOB_URL tested ${CACHE_REPO_KEY} ${TRAVIS_COMMIT} ${common_commit}
    fi

    ####
    # If this is a feature branch, then we don't deploy.
    ####
    if [ "$mode" = "feature" ]; then
        echo "Travis branch (${TRAVIS_BRANCH}) not a \"master\" nor a"
        echo "\"production-\" tag so not deploying."
        return;
    fi

    echo "travis_fold:start:__check_travis_cache_deployed"
    deployed=$(__check_travis_cache deployed ${CACHE_REPO_KEY} ${mode} ${TRAVIS_COMMIT} ${common_commit})
    echo "travis_fold:end:__check_travis_cache_deployed"

    if [ -n "$deployed" ]; then
        echo "This commit has been previously deployed successfully. Not deploying again."
        echo ""
        echo "The report from the previous deploy run can be seen here:"
        echo ""
        echo "$deployed"
        return
    fi

    if [ "$SITE" = "tss" ]; then
        echo "Travis is not authorized to deploy to the tss site."
        echo ""
        echo "A developer with the necessary credentials will need to manually"
        echo "deploy with a command such as:"
        echo ""
        echo "  make deploy-${mode} SITE=tss"
        echo ""
        echo "run from the top-level of the 'sites' repository."
        return
    fi

    __ensure_reqs_and_decrypt

    echo "travis_fold:start:deploy"
    deploy_args=$(./prepare-deploy ${mode} ${SITE} ${TRAVIS_BUILD_NUMBER})
    make -C ${SITE} deploy-${mode} ${deploy_args}
    echo "travis_fold:end:deploy"

    #####
    # Now that deployment has completed successfully, there are two
    # final tasks to be done:
    #
    # 1. For deployment to production, we need to add the new tag to
    #    the "sites" repository for the release, (and delete the
    #    production-$SITE tag that locks the whole process to a single
    #    concurrent deployment.
    #
    # 2. For any deploy, we add anew commit to the cache repository
    #    and push it out.
    ####

    SITE_VERSION=$(python ./setup.py --version)
    if [ $mode = "production" ]; then

        __configure_git_authorship

        git tag -a -m "Site $SITE release version $SITE_VERSION" $SITE-v$SITE_VERSION production-$SITE
        git push origin $SITE-v$SITE_VERSION
        git push origin :production-$SITE
    fi

    __store_travis_cache $NIFTY_TRAVIS_JOB_URL deployed ${CACHE_REPO_KEY} ${mode} ${TRAVIS_COMMIT} ${common_commit}
}

#####
# We store the coverage results for the master branch in the travis-cache
# repository. We compare current coverage test results to these store
# results, and if merging the current branch would result in a reduction
# of code test coverage, we fail the build.
#####
verify_coverage_improvement() {
    # Don't re-generate coverage if it already exists
    if [ -e ./.coverage ]; then
        echo "Found existing coverage results. Not regenerating."
    else
        if hash coverage 2> /dev/null; then
            make coverage
        else
            echo "Coverage testing cannot proceed because the coverage command could not be found."
            echo ""
            return 1
        fi
    fi

    # Print the coverage report, get the last line containing the coverage totals,
    # and remove the "%" from the total project coverage percentage.

    # Line of coverage report consisting of the coverage total figures
    coverage_totals=$(coverage report -m | tail -n 1)

    # Total coverage percentage number with the percent sign removed
    current_coverage=$(echo $coverage_totals | awk '{print $NF}' | cut -d "%" -f 1)

    # The last line that appeared in the coverage report is the line that
    # divides the column headers and the calcuated coverage totals. This
    # means that this report is empty and there is an error in the way coverage
    # is configured.
    if [[ $coverage_totals == "-"* ]]; then
        echo "This coverage report is empty. Please check the coverage settings and try again."
        echo ""
        return 1
    fi

    master_coverage=$(__check_travis_cache coverage ${CACHE_REPO_KEY} master)

    # If this repository has no coverage information saved for the master branch...
    if [ -z "$master_coverage" ]; then
        echo "The master branch has not previously been tested for coverage."
        echo ""
        # If this is not the master branch, report that we have no value to compare
        # coverage to and exit without failing.
        if [ "$TRAVIS_BRANCH" != "master" ]; then
            echo "Coverage comparison is being skipped."
            echo "This is because the master branch has no coverage value to compare against."
            echo ""
            return
        fi
    else
        echo "master branch total coverage: $master_coverage%"
        echo "$TRAVIS_BRANCH branch total coverage: $current_coverage%"
        echo ""
        # Fail this build if coverage would decrease.
        if [ $current_coverage -lt $master_coverage ]; then
            echo "Test coverage has decreased compared to the master branch!"
            echo "This build will be failed."
            echo ""
            return 1
        fi
        echo "Coverage comparison check was successful."
        echo ""
    fi

    # Coverage has increased. If Travis reports this branch as the master
    # branch and this is not a pull request, update the coverage figure
    # stored in the cache.
    if [[ $current_coverage -gt $master_coverage &&
          "$TRAVIS_BRANCH" = "master" &&
          "$TRAVIS_PULL_REQUEST" = "false" ]]; then
        __store_travis_cache $current_coverage coverage ${CACHE_REPO_KEY} master
        echo "Coverage cache updated successfully."
        echo ""
    fi

    return
}

#####
# Perform all necessary testing for an app
#
# This function assumes the following:
#
#
#	1. The app being tested has a "make reqs" target
#	2. The app being tested has a "make travis-tests" target
#	3. Either of the following are true:
#		a. The "make travis-tests" target generates .coverage
#	     or b. The app has a "make coverage" target (in this case
#                  the app's test suite will be run twice.
#
# When this function is complete, if the tests passed and coverage was
# at least the same or better, a new "travis-tested" tag will be
# pushed out to the app's repository.
#####
nifty_test_app() {

    # Travis appears to have an ancient setuptools installed as part
    # of its virtualenv. Recent versions of html5lib (at least as of
    # version 0.999999999) require at least version 18.5 or above for
    # setuptools. But since this isn't an expressed requirement, we
    # need to manually upgrade setuptools rather than just trusting
    # pip to do it for us as part of "make reqs"
    pip install --upgrade setuptools

    __ensure_latest_pip

    make reqs

    make travis-tests

    verify_coverage_improvement

    # Do not tag unless we are the master branch and this is not a PR
    if [[ "$TRAVIS_BRANCH" != "master" ||
          "$TRAVIS_PULL_REQUEST" = "true" ]]; then
        return
    fi

    # Also, do not tag if this is not a private repository. We detect
    # private repositories by looking for a "source_key" to be defined
    # in the .travis.yml file
    if ! grep -q ^source_key .travis.yml; then
        return
    fi

    __configure_git_authorship

    # Tag the current commit
    git tag -fm "Travis tested master" travis-tested
    git push origin +travis-tested
}

# The only thing this script immediately does when sourced is call
# __init_travis_cache to initialize our git-repository-based travis cache.
echo "travis_fold:start:init_travis_cache"
__init_travis_cache
echo "travis_fold:end:init_travis_cache"
