#!/bin/bash

# If any single line of this script fails, we want to exit and have
# Travis notice that as a test failure.
set -e

NIFTY_GIT_CONFIG_EMAIL=${NIFTY_GIT_CONFIG_EMAIL:=carl.worth+travis@nimbisservices.com}
NIFTY_TRAVIS_JOBS_URL_BASE=https://magnum.travis-ci.com/${TRAVIS_REPO_SLUG}/jobs
NIFTY_TRAVIS_JOB_URL=${NIFTY_TRAVIS_JOBS_URL_BASE}/${TRAVIS_JOB_ID}
NIFTY_TRAVIS_CACHE_DIR=${HOME}/.travis-cache
# This should be set by the .travis.yml file if the value needs to change,
# like when using a public cache repository.
NIFTY_TRAVIS_CACHE_REPO=${NIFTY_TRAVIS_CACHE_REPO:=git@github.com:nimbis/travis-cache}

# Two things that will need to be changed to switch to newer git-crypt
GITCRYPT_VERSION=0.5.0
GITCRYPT_SHA256=0a8f92c0a0a125bf768d0c054d947ca4e4b8d6556454b0e7e87fb907ee17cf06

# These shouldn't need changing
GITCRYPT_PACKAGE=git-crypt-$GITCRYPT_VERSION
GITCRYPT_TARFILE=$GITCRYPT_PACKAGE.tar.gz

# Primary key for travis cache. For this we use the TRAVIS_REPO_SLUG
# and then append the value of $SITE (if set) since we do multiple
# tests for different sites within the same repository.
CACHE_REPO_KEY=${TRAVIS_REPO_SLUG}${SITE:+-}${SITE}

# Absolute path for original clone of repository (so always easy to return to)
SITE_DIR=$(pwd)

reqs_and_decrypt="false"

#####
# At various times, Travis needs to create new git objects, (commits
# within the travis-cache repository, tags after deploying to
# production).
#
# In order to do that, git insists that the user have a valid
# name. So we need to put something in place.
#
# In lieu of any better information, I'll use my email address to take
# responsibility for any actions performed by this script.
#####

__configure_git_authorship() {
    git config user.email "${NIFTY_GIT_CONFIG_EMAIL}"
    git config user.name "${TRAVIS_REPO_SLUG} travis-metadata-script"
}

#####
# Ensure the git-crypt program is available. If not, download it, compile
# it and place it on the PATH.
#####
__ensure_git_crypt() {
    # Nothing to do if it's already available
    if which git-crypt; then
        return 0
    fi

    cd ${HOME}

    # Download git-crypt
    rm -f $GITCRYPT_TARFILE
    curl -O https://www.agwa.name/projects/git-crypt/downloads/$GITCRYPT_TARFILE

    # Check against a pre-computed sum. We're relying on Debian and
    # others having done due diligence before accepting git-crypt
    # 0.5.0 into their repository. This check ensures that what we're
    # downloading now hasn't been tampered with since then.
    echo "$GITCRYPT_SHA256  $GITCRYPT_TARFILE" > git-crypt.sha256
    sha256sum -c git-crypt.sha256

    # Extract source code

    tar xzf $GITCRYPT_TARFILE

    # Build and install the source

    cd $GITCRYPT_PACKAGE

    export PREFIX=
    export DESTDIR=${HOME}
    make
    make install

    export PATH=${HOME}/bin:$PATH

    cd ${SITE_DIR}

    return 0
}

__ensure_reqs_and_decrypt() {
    if [ "$reqs_and_decrypt" = "false" ]; then

        echo "travis_fold:start:npm"
        npm install -g grunt-cli
        npm install -g bower
        echo "travis_fold:end:npm"

        echo "travis_fold:start:decrypt"

        # We support both the "new" git-crypt based approach as well
        # as the previously-used git-encrypt based approach.

        if [ "$GIT_CRYPT_KEY" != "" ]; then
            __ensure_git_crypt
            echo "$GIT_CRYPT_KEY" | base64 -d > ${HOME}/gitcrypt-key
            git-crypt unlock ${HOME}/gitcrypt-key
            rm -f ${HOME}/gitcrypt-key
        else
            npm install -g git-encrypt
            git config filter.encrypt.smudge "gitcrypt smudge"
            git config filter.encrypt.clean "gitcrypt clean"
            git config diff.encrypt.textconv "gitcrypt diff"
            git config gitcrypt.salt ${GITCRYPT_SALT}
            git config gitcrypt.pass ${GITCRYPT_PASS}
            make decrypt
        fi

        echo "travis_fold:end:decrypt"

        echo "travis_fold:start:reqs"
        make reqs
        echo "travis_fold:end:reqs"

        reqs_and_decrypt="true"
    fi
}

#####
# Initialize our git-repository-based travis cache.
#
# This function must be called once before any other calls to
# travis_cache functions.
#####

__init_travis_cache() {
    if [ ! -e ${NIFTY_TRAVIS_CACHE_DIR} ]; then
       git clone ${NIFTY_TRAVIS_CACHE_REPO} ${NIFTY_TRAVIS_CACHE_DIR}
    fi

    cd ${NIFTY_TRAVIS_CACHE_DIR}
    # Switch to an absolute path for NIFTY_TRAVIS_CACHE_DIR for better reliability
    NIFTY_TRAVIS_CACHE_DIR=$(pwd)

    git pull --no-edit
    git reset --hard origin/master

    __configure_git_authorship

    cd ${SITE_DIR}
}

#####
# String together all function arguments. For any very long
# arguments, (that is, git commit IDs), split them into two pieces
# after the first two characters.
#####
__args_to_cache_path() {
    path=""

    while [ $# -gt 0 ]; do
    arg=$1
    shift
    if [ ${#arg} -gt 35 ]; then
        arg="${arg:0:2}/${arg:2}"
    fi
    path="${path:+$path/}$arg"
    done

    echo "$path"
}

#####
# Perform a lookup in our git-repository-based travis cache.
#
# This function prints a non-empty string on a cache hit, (which can
# be provided to the user as a URL to see the log from the previous
# Travis run).
#####
__check_travis_cache() {

    cd ${NIFTY_TRAVIS_CACHE_DIR}

    path=$(__args_to_cache_path "$@")

    if [ -e "$path" ]; then
       cat "$path"
    fi

    cd ${SITE_DIR}
}

#####
# Store an item in the travis cache
#
# The first argument should be a URL to store in the cache. All
# remaining arguments are the key, (and should match the arguments
# used later when calling __check_travis_cache).
#####
__store_travis_cache() {

    cd ${NIFTY_TRAVIS_CACHE_DIR}

    item="$1"
    shift

    echo "travis_fold:start:__store_travis_cache_$1"

    path=$(__args_to_cache_path "$@")

    mkdir -p $(dirname "$path")

    echo "$item" > "$path"

    git add "$path"
    git commit -a -m "Add item to travis cache" -m "Path of $path" -m "Item of $item"

    # If the first push fails, pull then push again. If that fails too, give up.
    git push origin master || git pull --no-edit && git push origin master || true

    cd ${SITE_DIR}

    echo "travis_fold:end:__store_travis_cache_$1"
}

#####
# Initialize all common and required aspects of the nifty environment,
# (git-based cache for travis test results, latest version of pip,
# Xvfb server running, etc.)
#####
__init_nifty_environment() {

    __init_travis_cache

    # Upgrade to latest pip
    #
    # Travis has pip 6.0.7 installed by default, which does not know how
    # to install a local version of a package (such as
    # django-shop==0.2.0+nimbis.1).
    pip install --upgrade pip


    # Upgrade to latest setuptools
    #
    # Travis has setuptools 12.0.5 installed by default, which does
    # have the support for environment markers that exists in v20.10.0
    # and later. This functionality is necessary when installing some
    # packages, such as html5lib v0.999999999 and django-shop v0.9.3
    pip install --upgrade setuptools

    # Start a headless X server, (for doing tests with a web browser)
    sh -e /etc/init.d/xvfb start
}

#####
# For a push to the sites repository, we push out corresponding
# commits (along with tags) to the site-$SITE repository as well as
# site-common. Those pushes will then result in testing and/or
# deployment from within the site-$SITE repository, so there's nothing
# else we need to do here, (no lettuce tests, no deployment, etc.)
#
#####
travis_for_sites() {

    echo "=================== Running Travis tests for site $SITE ==================="

    # If this is a commit being pushed to the master branch, then
    # we want to test and deploy to staging.
    #
    # Note: Travis is obnoxious in that it clobbers TRAVIS_BRANCH
    # with the tag name if a tag is being pushed, (even though the
    # same name is set in TRAVIS_TAG too). The upshot is that
    # pushing a tag at the same time as pushing to master will
    # prevent the detection of the master branch here, and will
    # prevent Travis from doing any deployment.
    #
    # If, instead, this is a push of a tag named
    # "production-$SITE" then we want to deploy to production, but
    # *only* for the particular site.
    #
    # Any other case is treated as a feature branch, (it will be
    # tested, but not deployed).

    case "$TRAVIS_BRANCH" in
    master)
        mode="staging"
        ;;
    production-*)
        if [ "$TRAVIS_BRANCH" = "production-$SITE" ]; then
            mode="production"
        else
            echo "This tag $TRAVIS_BRANCH was not intended for site $SITE"
            echo "Exiting"
            return
        fi
        if [ "$SITE" = "tss" ]; then
            echo "Travis is not authorized to deploy to the tss site."
            echo "Exiting"
            return
        fi
        ;;
    *)
        mode="feature"
        ;;
    esac

    #####
    # Check cache and don't repeat tests if succesfully tested before
    #####

    echo "travis_fold:start:__check_travis_cache_tested"
    tested=$(__check_travis_cache tested ${CACHE_REPO_KEY} ${TRAVIS_COMMIT} ${common_commit})
    echo "travis_fold:end:__check_travis_cache_tested"

    if [ -n "$tested" ]; then
        echo "This commit has previously been tested successfully. Not testing again."
        echo ""
        echo "The report from the previous run can be seen here:"
        echo ""
        echo "$tested"
    else

        __ensure_reqs_and_decrypt

        #####
        # Nuke all sites other than the one under test
        # (This avoids any accidental inter-site dependencies)
        #####

        for site in awesim nimbisservices smlc tss; do
            if [ "$site" != "$SITE" ]; then
                rm -rf $site
            fi
        done

        make travis-tests

        #####
        # Now that testing has completed successfully, add a new
        # commit to the cache repository and push it out.
        ####
        __store_travis_cache $NIFTY_TRAVIS_JOB_URL tested ${CACHE_REPO_KEY} ${TRAVIS_COMMIT} ${common_commit}
    fi

    ####
    # If this is a feature branch, then we don't deploy.
    ####
    if [ "$mode" = "feature" ]; then
        echo "Travis branch (${TRAVIS_BRANCH}) not a \"master\" nor a"
        echo "\"production-\" tag so not deploying."
        return;
    fi

    echo "travis_fold:start:__check_travis_cache_deployed"
    deployed=$(__check_travis_cache deployed ${CACHE_REPO_KEY} ${mode} ${TRAVIS_COMMIT} ${common_commit})
    echo "travis_fold:end:__check_travis_cache_deployed"

    if [ -n "$deployed" ]; then
        echo "This commit has been previously deployed successfully. Not deploying again."
        echo ""
        echo "The report from the previous deploy run can be seen here:"
        echo ""
        echo "$deployed"
        return
    fi

    if [ "$SITE" = "tss" ]; then
        echo "Travis is not authorized to deploy to the tss site."
        echo ""
        echo "A developer with the necessary credentials will need to manually"
        echo "deploy with a command such as:"
        echo ""
        echo "  make deploy-${mode} SITE=tss"
        echo ""
        echo "run from the top-level of the 'sites' repository."
        return
    fi

    __ensure_reqs_and_decrypt

    echo "travis_fold:start:deploy"
    deploy_args=$(./prepare-deploy ${mode} ${SITE} ${TRAVIS_BUILD_NUMBER})
    if [ $mode = "staging" ]; then
        make -C ${SITE} deploy-staging ${deploy_args}
    fi
    echo "travis_fold:end:deploy"

    #####
    # Now that deployment has completed successfully, there are two
    # final tasks to be done:
    #
    # 1. For deployment to production, we need to add the new tag to
    #    the "sites" repository for the release, (and delete the
    #    production-$SITE tag that locks the whole process to a single
    #    concurrent deployment.
    #
    # 2. For any deploy, we add anew commit to the cache repository
    #    and push it out.
    ####

    if [ $mode = "production" ]; then

        __configure_git_authorship

        SITE_VERSION=$(cd ${SITE}; python ./setup.py --version)
        git tag -a -m "Site $SITE release version $SITE_VERSION" $SITE-v$SITE_VERSION production-$SITE
        git push origin $SITE-v$SITE_VERSION
        git push origin :production-$SITE
    fi

    __store_travis_cache $NIFTY_TRAVIS_JOB_URL deployed ${CACHE_REPO_KEY} ${mode} ${TRAVIS_COMMIT} ${common_commit}
}

#####
# We store the coverage results for the master branch in the travis-cache
# repository. We compare current coverage test results to these store
# results, and if merging the current branch would result in a reduction
# of code test coverage, we fail the build.
#####
verify_coverage_improvement() {
    # Don't re-generate coverage if it already exists
    if [ -e ./.coverage ]; then
        echo "Found existing coverage results. Not regenerating."
    else
        if hash coverage 2> /dev/null; then
            make coverage
        else
            echo "Coverage testing cannot proceed because the coverage command could not be found."
            echo ""
            return 1
        fi
    fi

    # Print the coverage report, get the last line containing the coverage totals,
    # and remove the "%" from the total project coverage percentage.

    # Line of coverage report consisting of the coverage total figures
    coverage_totals=$(coverage report -m | tail -n 1)

    # Total coverage percentage number with the percent sign removed
    current_coverage=$(echo $coverage_totals | awk '{print $NF}' | cut -d "%" -f 1)

    # The last line that appeared in the coverage report is the line that
    # divides the column headers and the calcuated coverage totals. This
    # means that this report is empty and there is an error in the way coverage
    # is configured.
    if [[ $coverage_totals == "-"* ]]; then
        echo "This coverage report is empty. Please check the coverage settings and try again."
        echo ""
        return 1
    fi

    master_coverage=$(__check_travis_cache coverage ${CACHE_REPO_KEY} master)

    # If this repository has no coverage information saved for the master branch...
    if [ -z "$master_coverage" ]; then
        echo "The master branch has not previously been tested for coverage."
        echo ""
        # If this is not the master branch, report that we have no value to compare
        # coverage to and exit without failing.
        if [ "$TRAVIS_BRANCH" != "master" ]; then
            echo "Coverage comparison is being skipped."
            echo "This is because the master branch has no coverage value to compare against."
            echo ""
            return
        fi
    else
        echo "master branch total coverage: $master_coverage%"
        echo "$TRAVIS_BRANCH branch total coverage: $current_coverage%"
        echo ""
        # Fail this build if coverage would decrease.
        if [ $current_coverage -lt $master_coverage ]; then
            echo "Test coverage has decreased compared to the master branch!"
            echo "This build will be failed."
            echo ""
            return 1
        fi
        echo "Coverage comparison check was successful."
        echo ""
    fi

    # Coverage has increased. If Travis reports this branch as the master
    # branch and this is not a pull request, update the coverage figure
    # stored in the cache.
    if [[ $current_coverage -gt $master_coverage &&
          "$TRAVIS_BRANCH" = "master" &&
          "$TRAVIS_PULL_REQUEST" = "false" ]]; then
        __store_travis_cache $current_coverage coverage ${CACHE_REPO_KEY} master
        echo "Coverage cache updated successfully."
        echo ""
    fi

    return
}

#####
# Perform all necessary testing for an app
#
# This function assumes the following:
#
#
#	1. The app being tested has a "make reqs" target
#	2. The app being tested has a "make travis-tests" target
#	3. Either of the following are true:
#		a. The "make travis-tests" target generates .coverage
#	     or b. The app has a "make coverage" target (in this case
#                  the app's test suite will be run twice.
#
# When this function is complete, if the tests passed and coverage was
# at least the same or better, a new "travis-tested" tag will be
# pushed out to the app's repository.
#####
nifty_test_app() {

    make reqs

    make travis-tests

    verify_coverage_improvement

    # Do not tag unless we are the master branch and this is not a PR
    if [[ "$TRAVIS_BRANCH" != "master" ||
          "$TRAVIS_PULL_REQUEST" = "true" ]]; then
        return
    fi

    # Also, do not tag if this is not a private repository. We detect
    # private repositories by looking for a "source_key" to be defined
    # in the .travis.yml file
    if ! grep -q ^source_key .travis.yml; then
        return
    fi

    __configure_git_authorship

    # Tag the current commit
    git tag -fm "Travis tested master" travis-tested
    git push origin +travis-tested
}

# Main function

# Ensure all expected aspects of the nifty environment are in place,
# (git-based cache for travis test results, latest version of pip,
# Xvfb server running and correcti DISPLAY environment variable set,
# etc.)
__init_nifty_environment

# Test that we are invoked with an argument, (rather than the old
# approach we were using of sourcing nifty-script). Give a useful
# error message to help the developer massage their .travis.yaml
if [ "$#" -lt 1 ]; then
    echo "nifty-script should now be called with an argument giving the"
    echo "test mode (rather than being sourced). Fix up .travis.yaml"
    echo "to look like one of the following as appropriate:"
    echo ""
    echo "script:"
    echo "  - ./.nifty/nifty-script travis_for_sites"
    echo ""
    echo "script:"
    echo "  - ./.nifty/nifty-script nifty_test_app"
    exit 1
fi

# Then, invoke the desired nifty testing function depending on the
# argument passed to nifty-script
case "$1" in
    travis_for_sites)
        travis_for_sites
        ;;
    nifty_test_app)
        nifty_test_app
        ;;
    *)
        echo "Unsupported nifty test mode: $1"
        exit 1
        ;;
esac
